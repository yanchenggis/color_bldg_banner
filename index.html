<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Warisan KL â€” main_entit (grouped by building_i)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <style>
    body { margin: 0; padding: 0; background: #1a1a1a; }
    .banner-container {
      width: 100%;
      height: 80vh;
      min-height: 600px;
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg, rgba(15,93,244,1) 19%, rgba(33,200,117,1) 89%);
    }
    #map { position:absolute; top:0; bottom:0; width:100%; height:100%; }
    .content-overlay {
      position:absolute; top:75%; left:50px; transform:translateY(-50%);
      color:white; z-index:10; pointer-events:none;
    }
    .title { font-size:4em; font-weight:bold; margin-bottom:15px; text-shadow:3px 3px 8px rgba(0,0,0,0.7); font-family:Arial, sans-serif; }
    .subtitle { font-size:1.5em; opacity:0.9; text-shadow:2px 2px 6px rgba(0,0,0,0.7); font-family:Arial, sans-serif; }

    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 999;
      background: rgba(26,26,26,0.92);
      padding: 12px;
      border-radius: 8px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      color: white;
      max-width: 300px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
    }
    .legend h4 { margin: 0 0 8px 0; font-size: 13px; }
    .legend .row { display:flex; align-items:center; margin-bottom:6px; }
    .legend .swatch { width:14px; height:14px; margin-right:8px; border-radius:3px; border:1px solid rgba(255,255,255,0.12); }
    @media (max-width:768px) {
      .banner-container { height: 50vh; min-height: 400px; }
      .title { font-size: 2.5em; }
      .subtitle { font-size: 1.2em; }
      .legend { right: 8px; left: 8px; max-width:none; }
    }
  </style>
</head>
<body>
  <div class="banner-container">
    <div id="map"></div>
    <div class="content-overlay">
      <div class="title">Urban Analytics</div>
      <div class="subtitle">From Understanding Data to Developing Insights</div>
    </div>
    <div id="legend" class="legend"></div>
  </div>

<script>
/* ---------------- CONFIG ---------------- */
const PRECINCT_ZIP_URL = 'https://raw.githubusercontent.com/yanchenggis/color_bldg_banner/main/precinct.zip';
const BUILDING_ZIP_URL = 'https://raw.githubusercontent.com/yanchenggis/color_bldg_banner/main/KLCCD_core_building_processed.zip';

// palettes (adjust if you want)
const blockHighlightPalette = ['#E41A1C','#377EB8','#4DAF4A','#984EA3','#FF7F00','#FFFF33','#A65628'];
const pastelPalette = ['#FFD3B6','#FFAAA5','#A8E6CF','#D0BAFF','#FFFFB5','#B5EAD7','#C7CEEA','#FFDAC1','#E2F0CB','#B2F7EF'];

// flexible labels you can change (display names in legend)
const legendLabels = {
  // 'OriginalCategoryValue': 'Pretty label here'
  // add or edit as you like after loading
};

/* ----------------- map init ----------------- */
const map = new maplibregl.Map({
  container: 'map',
  style: 'https://tiles.openfreemap.org/styles/dark',
  center: [101.6941, 3.1500],
  zoom: 14.5,
  pitch: 55,
  bearing: 0,
  maxBounds: [[101.680, 3.135], [101.715, 3.165]]
});

/* global storage */
let precinctsGeo = null;
let buildingsGeo = null;
let entitField = null;        // e.g. 'main_entit'
let buildingIdField = null;   // e.g. 'building_i'
let entitCategories = [];
let entitColors = {};
let entitMatchExpression = null;
let buildingIdToIndices = {}; // { buildingId: [featureIndex, ...] }
let blockToFeatureIndices = {}; // { blockId: [featureIndex, ...] }

/* Helpers to detect field names robustly (case-insensitive) */
function detectField(feature, candidates){
  if(!feature || !feature.properties) return null;
  const keys = Object.keys(feature.properties);
  const lowerKeys = keys.map(k=>k.toLowerCase().trim());
  for(const c of candidates){
    const idx = lowerKeys.indexOf(c.toLowerCase());
    if(idx !== -1) return keys[idx]; // return actual key name
  }
  return null;
}

/* auto color assignment */
function assignColors(categories, palette){
  const map = {};
  categories.forEach((c, i) => map[c] = palette[i % palette.length]);
  return map;
}

/* build a match expression for MapLibre using the chosen field */
function buildMatchExpression(field, categories, colorMap, defaultColor){
  const expr = ['match', ['get', field]];
  for(const c of categories){
    expr.push(c, colorMap[c]);
  }
  expr.push(defaultColor);
  return expr;
}

/* join heights from OSM building source (best-effort) */
function joinHeightsFromOSM(buildingsGeo){
  const osmFeatures = map.querySourceFeatures('openmaptiles', { sourceLayer: 'building' }) || [];
  // quick bbox index
  const osmIndex = osmFeatures.map(f => ({ bbox: turf.bbox(f.geometry), feature: f }));
  buildingsGeo.features.forEach((f) => {
    let assigned = 12; // fallback height
    const bb = turf.bbox(f.geometry);
    for(const item of osmIndex){
      const ob = item.bbox;
      if(ob[0] > bb[2] || ob[2] < bb[0] || ob[1] > bb[3] || ob[3] < bb[1]) continue;
      try{
        if(turf.booleanIntersects(f.geometry, item.feature.geometry)){
          const h = item.feature.properties && (item.feature.properties.render_height || item.feature.properties.height);
          if(h && !isNaN(Number(h))){ assigned = Number(h); break; }
          if(item.feature.properties && item.feature.properties['building:levels']){
            assigned = Number(item.feature.properties['building:levels']) * 3; break;
          }
        }
      }catch(e){}
    }
    f.properties._height = assigned;
  });
}

/* build helpful indices:
   - buildingIdToIndices: to group all parts of same building
   - blockToFeatureIndices: which features intersect each block (feature indices)
*/
function buildIndices(){
  buildingIdToIndices = {};
  buildingsGeo.features.forEach((f, idx) => {
    const bid = String(f.properties[buildingIdField] ?? f.properties.building_i ?? f.properties.id ?? idx);
    if(!buildingIdToIndices[bid]) buildingIdToIndices[bid] = [];
    buildingIdToIndices[bid].push(idx);
    // keep a normalized building id field for ease later
    f.properties.__buildingId_norm = bid;
  });

  // block->feature index by intersection (bbox prefilter)
  const buildingBboxes = buildingsGeo.features.map(f => turf.bbox(f.geometry));
  precinctsGeo.features.forEach((blk) => {
    const blockId = blk.properties.Block ?? blk.properties.block ?? blk.id ?? (precinctsGeo.features.indexOf(blk));
    blockToFeatureIndices[blockId] = [];
    const bb = turf.bbox(blk.geometry);
    for(let i=0;i<buildingsGeo.features.length;i++){
      const bbb = buildingBboxes[i];
      if(bbb[0] > bb[2] || bbb[2] < bb[0] || bbb[1] > bb[3] || bbb[3] < bb[1]) continue;
      try {
        if(turf.booleanIntersects(blk.geometry, buildingsGeo.features[i].geometry)){
          blockToFeatureIndices[blockId].push(i);
        }
      } catch(e){}
    }
  });
}

/* set all features inBlock flag (initially false - grey) */
function resetAllInBlockFlag(val=false){
  buildingsGeo.features.forEach(f => f.properties.inBlock = val);
}

/* ---------- add layers & interactivity ---------- */

map.on('load', async () => {
  // 1) OSM base grey 3D buildings (bottom-most)
  map.addLayer({
    id: 'osm-3d-base',
    type: 'fill-extrusion',
    source: 'openmaptiles',
    'source-layer': 'building',
    paint: {
      'fill-extrusion-color': '#555555',
      'fill-extrusion-height': ['get','render_height'],
      'fill-extrusion-base': ['get','render_min_height'],
      'fill-extrusion-opacity': 0.85
    }
  });

  // 2) load precincts (shapefile)
  try {
    const pResp = await fetch(PRECINCT_ZIP_URL);
    const pBuf = await pResp.arrayBuffer();
    const pGeo = await shp(pBuf);
    // sometimes shp.js returns an object keyed by filename; pick FeatureCollection
    precinctsGeo = (pGeo.type === 'FeatureCollection') ? pGeo : Object.values(pGeo).find(v=>v && v.type==='FeatureCollection');
    if(!precinctsGeo) throw new Error('No precinct featurecollection found');

    // give id and color for legend
    precinctsGeo.features.forEach((f,i)=>{
      if(!('Block' in f.properties)) f.properties.Block = String(i);
      f.id = f.properties.Block ?? i;
      f.properties._color = blockHighlightPalette[i % blockHighlightPalette.length];
    });

  } catch(err){
    console.error('Failed loading precincts:', err);
    return;
  }

  // 3) load processed building shapefile (your KLCCD_core_building_processed.zip)
  try {
    const bResp = await fetch(BUILDING_ZIP_URL);
    const bBuf = await bResp.arrayBuffer();
    const bGeo = await shp(bBuf);
    buildingsGeo = (bGeo.type === 'FeatureCollection') ? bGeo : Object.values(bGeo).find(v=>v && v.type==='FeatureCollection');
    if(!buildingsGeo) throw new Error('No building featurecollection found');
  } catch(err){
    console.error('Failed loading buildings:', err);
    return;
  }

  // ---------- detect fields ----------
  // choose best candidates if field is named slightly differently
  const entitCandidates = ['main_entit','Main_entit','mainEntit','Superlucsa','SuperLucsa','main_entit '];
  const buildIdCandidates = ['building_i','building_id','bldg_id','bldg_i','osm_id','id','BUILDING_I'];

  // detect on first building feature
  const sample = buildingsGeo.features[0];
  entitField = detectField(sample, entitCandidates) || (() => { console.warn('main_entit not found, falling back to "main_entit"'); return 'main_entit'; })();
  buildingIdField = detectField(sample, buildIdCandidates) || (() => { console.warn('building_i not found, falling back to "building_i"'); return 'building_i'; })();

  console.log('Detected fields:', { entitField, buildingIdField });

  // normalize presence and create __mainEntit and __buildingId fields for consistent use
  buildingsGeo.features.forEach((f) => {
    const entitVal = f.properties[entitField] ?? f.properties[entitField.toLowerCase()] ?? f.properties.Superlucsa ?? f.properties.Lucsa ?? 'Unknown';
    f.properties.__mainEntit_norm = String(entitVal);
    const bid = String(f.properties[buildingIdField] ?? f.properties.building_i ?? f.properties.id ?? buildingsGeo.features.indexOf(f));
    f.properties.__buildingId_norm = bid;
    f.properties.inBlock = false; // default: grey
  });

  // ---------- categories & colors ----------
  entitCategories = Array.from(new Set(buildingsGeo.features.map(f => f.properties.__mainEntit_norm)));
  entitColors = assignColors(entitCategories, pastelPalette);
  entitMatchExpression = buildMatchExpression('__mainEntit_norm', entitCategories, entitColors, '#CFCFCF');

  // apply heights from OSM where possible
  joinHeightsFromOSM(buildingsGeo);

  // build indices for quick lookup
  buildIndices();

  // reset inBlock flags (grey by default)
  resetAllInBlockFlag(false);

  // 4) add source & 3D layer for your processed buildings (entit) - on top of OSM base
  map.addSource('entit-buildings', { type: 'geojson', data: buildingsGeo });

  map.addLayer({
    id: 'entit-buildings-3d',
    type: 'fill-extrusion',
    source: 'entit-buildings',
    paint: {
      // if inBlock true -> color by __mainEntit_norm; else grey
      'fill-extrusion-color': [
        'case',
        ['==', ['get', 'inBlock'], true],
        entitMatchExpression,
        '#777777'
      ],
      'fill-extrusion-height': ['get', '_height'],
      'fill-extrusion-base': 0,
      'fill-extrusion-opacity': 0.98
    }
  }, /* insertBefore */);

  // 5) add precinct highlight BELOW the entit buildings (so buildings sit visually above highlight),
  //    but we also add a transparent hit layer on top to capture mouse events and an outline on top.
  map.addSource('precincts-src', { type: 'geojson', data: precinctsGeo });

  // highlight (inserted before entit-buildings-3d so it's below them)
  map.addLayer({
    id: 'precinct-highlight',
    type: 'fill',
    source: 'precincts-src',
    paint: {
      'fill-color': ['get', '_color'],
      'fill-opacity': 0.22
    },
    filter: ['==', ['get', 'Block'], '__none__']
  }, 'entit-buildings-3d');

  // outline on top (visible)
  map.addLayer({
    id: 'precinct-outline',
    type: 'line',
    source: 'precincts-src',
    paint: { 'line-color': '#ffffff', 'line-width': 1.4, 'line-opacity': 0.6 }
  });

  // invisible hit layer on very top for mouse events (so hover works even when buildings sit above)
  map.addLayer({
    id: 'precinct-hit',
    type: 'fill',
    source: 'precincts-src',
    paint: { 'fill-color': '#000', 'fill-opacity': 0 }
  });

  // 6) interaction - hover behavior
  let lastHoveredBlockId = null;
  map.on('mousemove', 'precinct-hit', (e) => {
    if(!e.features || !e.features.length) return;
    const feat = e.features[0];
    const blockId = feat.properties.Block ?? feat.id ?? precinctsGeo.features.indexOf(feat);
    if(blockId === lastHoveredBlockId) return; // nothing changed

    // set highlight filter to show this block (highlight layer is below entit)
    map.setFilter('precinct-highlight', ['==', ['get', 'Block'], blockId]);

    // compute set of building IDs that intersect this block (use precomputed indices)
    const featureIndices = blockToFeatureIndices[blockId] || [];
    const buildingIdsInBlock = new Set();
    for(const fi of featureIndices){
      const bid = buildingsGeo.features[fi].properties.__buildingId_norm;
      buildingIdsInBlock.add(bid);
    }

    // mark every building feature as inBlock if its buildingId is in buildingIdsInBlock
    for(const f of buildingsGeo.features){
      f.properties.inBlock = buildingIdsInBlock.has(f.properties.__buildingId_norm);
    }

    // push updated data (fast)
    map.getSource('entit-buildings').setData(buildingsGeo);

    lastHoveredBlockId = blockId;
  });

  map.on('mouseleave', 'precinct-hit', () => {
    // clear highlight
    map.setFilter('precinct-highlight', ['==', ['get', 'Block'], '__none__']);
    lastHoveredBlockId = null;
    // reset buildings to grey
    resetAllInBlockFlag(false);
    map.getSource('entit-buildings').setData(buildingsGeo);
  });

  // 7) build legend and show which fields were detected
  buildLegend();
  console.log('main_entit field used (normalized): __mainEntit_norm');
  console.log('building id field used (normalized): __buildingId_norm');
});

/* ---------------- Legend builder & utils ---------------- */
function buildLegend(){
  const legend = document.getElementById('legend');
  legend.innerHTML = '<h4>Legend</h4>';
  legend.innerHTML += '<div style="font-weight:600;margin-top:6px;">Building class (main_entit)</div>';
  // show colours for categories (use legendLabels map when available)
  for(const cat of entitCategories){
    const label = legendLabels[cat] ?? cat;
    const color = entitColors[cat] ?? '#CFCFCF';
    const row = document.createElement('div'); row.className = 'row';
    row.innerHTML = `<div class="swatch" style="background:${color}"></div><div style="line-height:14px;">${label}</div>`;
    legend.appendChild(row);
  }
  // block legend (simple)
  const hr = document.createElement('div'); hr.style.marginTop = '8px';
  legend.appendChild(hr);
  legend.innerHTML += '<div style="font-weight:600;margin-top:8px;">Blocks (hover)</div>';
  precinctsGeo.features.forEach(f=>{
    const b = document.createElement('div'); b.className = 'row';
    b.innerHTML = `<div class="swatch" style="background:${f.properties._color}"></div><div style="line-height:14px;">Block ${f.properties.Block}</div>`;
    legend.appendChild(b);
  });
}

/* ------------- end script -------------- */
</script>
</body>
</html>
